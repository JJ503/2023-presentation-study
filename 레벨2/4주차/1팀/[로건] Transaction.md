# Transaction

## 1. 데이터베이스의 트랜잭션

---

> 데이터베이스에서 상호작용의 단위
> 

`create table`, `drop table`, `alter table` → 테이블과의 상호작용

`select`,`insert`, `update`, `delete` → 테이블 내부 값과의 상호작용

 …

> 작업을 하나로 묶어서 하나의 상호작용으로 만들면 이것도 하나의 트랜잭션
> 

```jsx
<--- TRANSACTION START --->

INSERT INTO car VALUES ...
INSERT INTO track VALUES ...

<---  TRANSACTION END  --->
```

---

## 2. 트랜잭션은 ACID가 보장되어야 한다.

---

- 원자성 (Atomicity)
하나의 트랜잭션 작업 도중에 실패해서는 안된다.
트랜잭션의 모든 작업이 완전히 수행되거나, 전혀 수행되지 않아야 한다.
`All or Nothing`
- 일관성 (Consistency)
트랜잭션이 수행되어도 모든 데이터가 일관성을 유지해야한다.
일관성 → 무결성 제약 조건, 도메인 제약 조건, 비즈니스 규칙을 만족해야함
- 고립성 (Isolation)
트랜잭션 작업 동안에는 다른 트랜잭션에 영향을 주어서도 안되고, 영향을 받아서도 안된다.
- 지속성 (Durability)
트랜잭션 작업이 성공하면 변경된 데이터는 영원히 반영되어야 한다.
그리고 트랜잭션 로그를 남겨서 트랜잭션 수행 전으로 되돌릴 수도 있어야 한다.

---

## 3. 트랜잭션 제어

---

### COMMIT

트랜잭션 작업이 성공적으로 완료됐다는 것을 알리는 명령

데이터베이스에 영구적으로 저장함

### ROLLBACK

트랜잭션 작업 도중에 오류가 발생하거나, 사용자가 해당 트랜잭션 작업 도중에 취소를 하고 싶으면 사용하는 명령
데이터베이스는 해당 트랜잭션 작업을 시작하기 이전으로 돌아감

### SAVEPOINT

트랜잭션 작업 도중에 특정 지점에 표시를 나타내는 것

트랜잭션 작업의 일부만 롤백하고 싶을 때 사용함

세이브 포인트를 저장하고(`SAVEPOINT [세이브 포인트 이름]`), `ROLLBACK TO [세이브 포인트 이름]`으로 롤백할 수 있음

![https://user-images.githubusercontent.com/79046106/234759000-0723e05e-2571-4bbd-841f-cdc8afa7ac17.png](https://user-images.githubusercontent.com/79046106/234759000-0723e05e-2571-4bbd-841f-cdc8afa7ac17.png)

---

## 4. 트랜잭션의 격리 수준 (고립 수준)

---

> 고립성: 트랜잭션 작업 동안에는 다른 트랜잭션에 영향을 주어서도 안되고, 영향을 받아서도 안된다.
> 

→ 현실에서는 성능과의 타협을 위해 격리 수준을 나눔

격리 수준을 나눔으로인해 발생하는 문제

- `Dirty Read` : 다른 트랜잭션에서 수정됐지만, 아직 커밋되지 않은 데이터를 읽을 때

![https://user-images.githubusercontent.com/79046106/235606179-24cf04ba-a243-48ee-87df-b911d9b7e90c.png](https://user-images.githubusercontent.com/79046106/235606179-24cf04ba-a243-48ee-87df-b911d9b7e90c.png)

- `Non Repeatable Read` : 한 트랜잭션에서 특정 값을 여러 번 읽었는데, 읽는 사이에 값이 수정/삭제되어 같은 값에 대한 조회가 서로 다르게 나올 때

![https://user-images.githubusercontent.com/79046106/235606268-cee8be3a-c7ce-4d4f-a116-ebc079e8bbec.png](https://user-images.githubusercontent.com/79046106/235606268-cee8be3a-c7ce-4d4f-a116-ebc079e8bbec.png)

- `Phantom Read`: 한 트랜잭션에서 같은 쿼리를 두 번 읽었는데, 읽는 사이에 삽입 쿼리를 날려서 처음 쿼리에는 없던 유령 레코드가 두 번째 쿼리에 나올 때

![https://user-images.githubusercontent.com/79046106/235606268-cee8be3a-c7ce-4d4f-a116-ebc079e8bbec.png](https://user-images.githubusercontent.com/79046106/235606268-cee8be3a-c7ce-4d4f-a116-ebc079e8bbec.png)

### [1] READ UNCOMMITTED

트랜잭션에서 아직 커밋되지 않았지만, 변경된 데이터를 다른 트랜잭션에서 읽을 수 있다.

- `Dirty Read`, `Non Repeatable Read`, `Phantom Read` 모두 발생

### [2] READ COMMITTED

커밋된 트랜잭션만 다른 트랜잭션이 읽을 수 있음

- `Non Repeatable Read`, `Phantom Read` 발생

### [3] REPEATABLE READ

한 트랜잭션에서 읽은 데이터가 다른 트랜잭션에 의해 변경되지 않도록 함. 그래서 같은 트랜잭션에서 같은 데이터를 여러 번 읽어도 똑같은 값을 얻을 수 있음

- `Phantom Read` 발생

### [4] SERIALIZABLE

가장 엄격한 고립 수준으로 말 그대로 순차적으로 트랜잭션을 처리한다.

데이터를 수정할 때, 다른 곳에서 SELECT 문을 실행해도 락이 걸려서 접근하지 못한다.

- 문제가 발생하지 않음


    추가 키워드
    위 내용을 넘어서 더 깊이 공부한다면 MySQL 공식 문서에 `Lock`, `Snapshot`에 대해 나오는데, 아래 키워드를 알고 공부하면 수월합니다.
    
    - `InnoDB`: MySQL의 기본 엔진으로 데이터를 삽입/수정/삭제할 때, 해당 테이블의 레코드만 락이 걸림
    - `MyIsam`: MySQL의 엔진중에 하나로 데이터를 삽입/수정/삭제할 때, 해당 테이블 전체에 락이 걸림
    - `Shared Lock`(`Read Lock`, `S-Lock`): 어떤 트랜잭션에서 특정 데이터를 읽을 때, 해당 데이터를 수정 불가능하게 만드는 락
    - `Exclusive Lock`(`Write Lock`, `X-Lock`): 어떤 트랜잭션에서 특정 데이터를 삽입/변경/삭제할 때, 해당 레코드를 다른 트랜잭션에서 읽거나, 쓰지 못하게 막는 락
    - `Record Lock`: 개별 레코드에 `S-Lock`, `X-Lock`을 설정하는 것
    - `Gap Lock`: 레코드 간의 빈 공간(gap)에 락을 거는 것 (새로운 insert를 막음)
    - `Next Key Lock`: `Record Lock` + `Gap Lock` 섞은 락
    - `Snapshot`: 데이터베이스의 읽기 전용 정적 보기 방법
    

---

## 5. 트랜잭션의 동시성 문제

---

(직렬성의 반대)

여러 명의 클라이언트가 여러 개의 트랜잭션을 동시에 수행할 때, 아래와 같은 상황이 발생할 수 있음

### [1] Lost Update

두 개의 트랜잭션이 있을 때, 하나의 트랜잭션이 다른 트랜잭션이 갱신한 값을 덮어쓰는 행동

ex) 은행의 어떤 계좌에 100,000원이 있는 상태

1. 트랜잭션 A와 B가 트랜잭션을 시작함
2. 트랜잭션 A가 50,000원을 인출함 (현재 금액: 100,000원)
3. 트랜잭션 B가 30,000원을 입금함 (현재 금액: 100,000원)
4. 트랜잭션 A가 커밋함 (현재 금액: 50,000원)
5. 트랜잭션 B가 커밋함 (현재 금액: 130,000원)

→ 예상 값: 80,000원, 실제 값: 130,000원

### [2] Inconsistency

한 트랜잭션이 여러 개의 값을 갱신하는 전후로 다른 트랜잭션이 해당 값들을 읽는 경우, 커밋 이전의 값과 커밋 이후의 값을 참조하기 때문에 모순이 생김

ex) 은행에 철수 - 100,000원, 영희 - 50,000원이 있는 상태

1. 트랜잭션 A와 B가 트랜잭션을 시작함
2. 트랜잭션 A가 철수의 값을 읽음 (철수: 100,000원)
3. 트랜잭션 A가 철수에게 10,000원을 입금함 (철수: 110,000원)
4. 트랜잭션 B가 철수와 영희의 값을 읽음 (철수: 110,000원, 영희: 50,000원)
5. 트랜잭션 B가 철수와 영희의 계좌를 2배 올림 (철수: 220,000원, 영희: 100,000원)
6. 트랜잭션 A가 영희의 값을 읽음 (영희: 100,000원)
7. 트랜잭션 A가 영희에게 10,000원을 입금함 (영희: 110,000원)

예상값 : 철수 220,000원, 영희 120,000원

실제값 : 철수 220,000원, 영희 110,000원

### [3] Dirty Read

트랜잭션 A가 특정 값을 쓰기 작업을 한 뒤에 다른 트랜잭션이 쓰기 작업이 된 값을 참조하는 상황. 트랜잭션 A가 롤백되어 트랜잭션 B가 무효된 값을 가지고 작업을 할 때 문제가 발생

ex) 계좌에 100,000원이 있을 때

1. 트랜잭션 A와 B가 트랜잭션을 시작함
2. 트랜잭션 A가 계좌 값을 읽음 (100,000원)
3. 트랜잭션 A가 계좌에 50,000원을 추가함 (150,000원)
4. 트랜잭션 B가 계좌 값을 읽음 (150,000원)
5. 트랜잭션 A가 롤백되어짐 (100,000원)
6. 트랜잭션 B는 무효된 값으로 작업을 계속 진행함

### [4] Cascading Rollback

두 개의 트랜잭션이 하나의 값을 수정하는 작업을 진행했고, 한 트랜잭션은 커밋된 상태인데, 다른 트랜잭션에서 롤백을 하여 이미 커밋된 트랜잭션도 롤백을 해야하는 상황

### 문제 해결 방법

- 락, 낙관적 락, 비관적 락, …

---

## 6.  @Transactional

---

스프링 코드에서 트랜잭션을 수행할 수 있도록 도와줌

### [1] Propagation

트랜잭션의 경계를 설정할 수 있는 파라미터

```java
REQUIRED
SUPPORTS
MANDATORY
REQUIRES_NEW
NOT_SUPPORTED
NEVER
NESTED
```

1. `REQUIRED` (기본값)
    - 이미 실행중인 트랜잭션이 있으면 해당 트랜잭션에 들어감
    - 실행중인 트랜잭션이 없으면 새로운 트랜잭션을 생성해서 실행함
2. `SUPPORTS`
    - 이미 실행중인 트랜잭션이 있으면 해당 트랜잭션에 들어감
    - 실행중인 트랜잭션이 없으면 트랜잭션 없이 실행함
3. `MANDATORY`
    - 이미 실행중인 트랜잭션이 있으면 해당 트랜잭션에 들어감
    - 실행중인 트랜잭션이 없으면 예외가 발생함
4. `REQUIRES_NEW`
    - 항상 새로운 트랜잭션을 생성함
    - 이미 실행중인 트랜잭션이 있으면 해당 트랜잭션을 잠시 중단함
5. `NOT_SUPPORTED`
    - 트랜잭션을 지원하지 않음
    - 이미 실행중인 트랜잭션이 있으면 해당 트랜잭션을 잠시 중단함
6. `NEVER`
    - 트랜잭션을 사용하지 않음
    - 이미 실행중인 트랜잭션이 있으면 예외가 발생함
7. `NESTED`
    - 이미 실행중인 트랜잭션이 있으면 중첩 트랜잭션을 생성하여 실행함
    부모 트랜잭션은 자식 트랜잭션이 시작되기 전에  `SAVEPOINT`를  저장함 (부분 롤백이 가능)
    - 이미 실행중인 트랜잭션이 없으면 새로운 트랜잭션을 생성하여 실행함

### [2] Isolation

트랜잭션의 고립 수준을 설정하는 파라미터

```java
DEFAULT
READ_UNCOMMITTED
READ_COMMITTED
REPEATABLE_READ
SERIALIZABLE
```

- `DEFAULT`: DBMS의 기본 고립 수준을 따라감 (기본값)
    - `H2`: Read Committed
    - `MySQL`: Repeatable Read
    - `PostgreSQL`: Read Committed
- 나머지는 위에서 설명함

### [3] readOnly  🌟

읽기 전용 트랜잭션을 생성함 (기본값 = `false`)

미션 코드에 `findById`, `findAll`에 적용하면 좋음

- 성능 최적화 ([참조](https://dev.mysql.com/doc/refman/8.0/en/innodb-performance-ro-txn.html))
- 읽기 전용이라는 명시적인 내용
- 데이터가 변경되는걸 사전에 방지

---

## 7.  JPA에서의 동시성 문제 해결 방법

---

### [1] 낙관적 락

데이터를 갱신할 때, 다른 트랜잭션과 충돌이 일어나지 않는다고 가정하는 방식

- 충돌이 일어나지 않는다고 생각하기에 락을 걸지 않음
- 트랜잭션 커밋 전까지 충돌 여부를 알 수 없음
- Application Level에서 동시성을 처리

### [2] 비관적 락

데이터를 갱신할 때, 다른 트랜잭션과 충돌이 일어날 것이라고 가정하는 방식

- 동시에 데이터에 접근할 것이라고 생각하기 때문에 락을 걸음
- 데이터 수정시 바로 충돌 여부를 알 수 있음
- DB Level에서 동시성을 처리

---

## 8. 추가 내용

---

### ThreadLocal

- 상위 메서드에 Transactional이 붙어 있을 때, 서로 다른 하위 메서드에서 DB 접근을 해도 하나의 트랜잭션으로 처리할 수 있는 이유
<br/> → `ThreadLocal`에 `Connection`이 저장되어 있음 
<br/> → 장점이자 단점: 단일 스레드에서만 Transactional 사용 가능 
<br/> (`ThreadLocal` 발표 스터디 자료 참조)
- 그러면 여러 개의 스레드를 사용하여 하나의 거대한 트랜잭션을 만들고 싶으면?
<br/> → 하나의 거대한 트랜잭션 = 분산 트랜잭션
<br/> → `Two-Phase Commit Protocol` 을 적용하여 분산 트랜잭션을 보장함
<br/> → 분산 트랜잭션은 MSA와 관련이 있으므로 패스
<br/> (`JtaTransactionManager`를 사용하여 분산 트랜잭션을 관리함)
