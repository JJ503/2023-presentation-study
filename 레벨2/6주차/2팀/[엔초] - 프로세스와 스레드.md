# 프로세스와 스레드

# 프로세스, 프로세서, 프로그램의 차이

## 프로그램(Program)

- 실행 가능한 코드의 집합
- 파일 시스템에 저장되어 있으며, 실행시키면 운영체제에 의해 프로세스로 로드된다.

## 프로세서 (Processor)

- *Processor의 사전적 의미 : 처리기*
- 컴퓨터 내에서 프로그램을 수행하는 하드웨어, 즉 중앙 처리 장치를 의미하며, CPU가 프로세서에 해당한다.

## 프로세스 (Process)

- *Process의 사전적 의미 : 절차, 과정*
- 운영체제에서 실행 중인 프로그램의 인스턴스
- 프로그램 실행 파일이 메머리에 적재되어 CPU를 할당받아 실행되는 것
- 각 프로세스는 독립된 메모리 공간, 실행 상태, 스레드 등을 가지고 있다.
- 각 프로세스는 운영체제로부터 자원을 할당받고, 프로그램의 실행을 제어한다.
- CPU는 한 번에 하나의 프로세스만 관리할 수 있다.
- 우리가 컴퓨터에서 동시에 여러 개의 프로그램을 실행시킬 수 있는 이유는, CPU가 빠른 속도로 스위칭을 해가며 각각의 프로세스를 순차적으로 실행신키기 때문에, 여러 프로그램이 동시에 실행되는 것처럼 보이는 것이다.

`정리하자면, 개발자가 작성한 소스코드와 소스코드가 컴파일 된 바이너리 파일 등, 파일로 저장된 코드는 **프로그램** 이라고 하고, 그 프로그램이 메모리에 적재되어 프로세서에 의해 실행 중이거나 실행  대기 중일 때는 **프로세스** 가 되는 것이다.`

## 프로그램은 어떻게 실행되는가?

**1. 프로그램 실행 버튼을 누른다.**

**2. 파일 형태로 저장되어 있는 프로그램이 로더(loader)에 의해 메모리에 적재된다.**

**3. 처음으로 실행해야 할 기계어 코드가 저장된 메모리의 주소를 CPU의 프로그램카운터(PC)에 저장한다.**

**4. 프로세서(CPU)가 프로그램카운터가 가리키는 메모리 주소에서 명령어를 인출하여 IR**(Instruction Register, 즉 명령 레지스터)**에 저장한다.**

**5. IR에 저장된 명령을 실행하고 프로그램카운터에 다음 번에 실행할 명령어가 있는 주소를 저장한다.**

실행파일로 존재하던 프로그램이 메모리에 적재될 때 `stack`, `heap`, `data`, `code` 총 4개의 구역에 나뉘어 저장된다.

![Untitled](https://rapid-browser-8fb.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F7bf2ddc3-1dbe-40c2-a49b-7c088f6609fb%2FUntitled.png?id=e02ca9ab-cb8b-4418-a626-df48e7c5c076&table=block&spaceId=46a9d753-8b1d-4083-bd7d-4b5f6daf3c1f&width=650&userId=&cache=v2)

```java
public static void main(String[] args) {
		System.out.println("안녕하세요");
    int sum = add(5, 10);
    int number = modifyNumber(sum);
}

private static int add(int a, int b) {
    return a + b;
}

private static int modifyNumber(int sum) {
    if (sum > 10) {
        return 0;
    }
    return sum;
}
```

```nasm
[**add 함수]**
80000    add:
80004        push ebp                 ; 이전 스택 프레임의 베이스 포인터 저장
80008        mov ebp, esp             ; 현재 스택 프레임의 베이스 포인터 설정

80012        mov eax, [ebp+8]         ; 첫 번째 인자 a 로드
80016        mov ebx, [ebp+12]        ; 두 번째 인자 b 로드
80020        add eax, ebx             ; a + b 계산 결과 eax에 저장

80024        mov esp, ebp             ; 스택 프레임 정리
80028        pop ebp
80032        ret

[**modifyNumber 함수]**
90000    modifyNumber:
90004        push ebp                 ; 이전 스택 프레임의 베이스 포인터 저장
90008        mov ebp, esp             ; 현재 스택 프레임의 베이스 포인터 설정

90012        mov eax, [ebp+8]         ; 인자 sum 로드
90016        cmp eax, 10              ; sum > 10 비교
90020        jg greater_than_10       ; 만약 sum > 10 이면 greater_than_10 레이블로 분기

             ; sum <= 10 인 경우
90024        mov edx, eax             ; 결과값을 edx에 복사
90028        jmp end_modifyNumber     ; end_modifyNumber 레이블로 분기

90032    greater_than_10:             ; sum > 10 인 경우
90036        mov eax, 0               ; 결과값 0을 eax에 설정

90040    end_modifyNumber:
90044        mov esp, ebp             ; 스택 프레임 정리
90048        pop ebp
90052        ret
```

# 프로세스 vs 스레드

## 프로세스

- 운영체제에서 실행중인 프로그램의 인스턴스
- 독립된 메모리 공간을 가지며, 각각의 프로세스는 운영체제로부터 할당받은 자원을 사용한다.
- 독립된 실행 흐름을 가지고 있어서 다른 프로세스의 영향을 받지 않는다.
- 독립적으로 실행되기 때문에 안전성과 보안이 높지만, 비용이 많이 들고 복잡하다.

## 스레드

- 하나의 프로세스 내에서 실행되는 여러 실행 흐름
- 동일한 메모리 공간을 공유하므로, 하나의 스레드가 다른 스레드에서 생성한 데이터에 접근할 수 있다.
- 프로세스의 자원을 공유하기 때문에 프로세스 간의 통신보다 효율적이지만, 스레드 간의 동기화와 경쟁 조건 등의 문제에 유의해야 한다.

### 스레드의 단점

- 멀티스레딩 환경에서
    - 예를 들어 두 스레드가 동시에 같은 변수를 증가시키는 연산을 수행할 때 한 스레드의 증가 연산이 무시되거나 중복되는 등의 문제가 발생할 수 있음
    - 여러 스레드가 동시에 접근해서는 안 되는데 영역(임계 영역)에 여러 스레드가 동시에 접근하면 데이터의 일관성을 해치거나 잘못된 결과를 얻을 수 있음
    - 한 스레드가 데이터를 수정하는 도중에 다른 스레드가 그 데이터를 읽는 경우, 수정 중인 데이터를 잘못된 상태로 읽을 수 있음
    - 둘 이상의 스레드가 서로가 가지고 있는 자원을 점유하고 있는 상태로 무한 대기에 빠지는 문제가 발생할 수 있음

### 동기화 메커니즘

- **락(Lock)**
    - 임계 영역에 진입하기 전에 스레드들이 경합하여 락을 획득하고, 사용이 끝나면 락을 반납하도록 하여 한 번에 하나의 스레드만이 임계 영역에 진입하도록 함
- **조건 변수**
    - 스레드 간의 통신을 위해 사용되며, 특정 조건이 충족될 때까지 스레드를 대기시킬 수 있다.
- **동기화 객체**
    - 읽기 작업에 대한 동시 접근을 허용하고, 쓰기 작업에 대한 배타적 접근을 허용
